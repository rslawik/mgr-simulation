= mgr-simulation
:icons: font
Rafał Sławik <rafal.slawik@gmail.com>

Simulation framework for online packet scheduling algorithms.

== Overview

Framework allows to simulate a scheduling algorithm against some adversary,
who has control over packet arrivals and error injections.
When algorithm under test makes a scheduling decision, adversary is asked to schedule an error.

NOTE: It is required to implement an algorithm and an adversary in a special form.

== Installation

The simulation framework works on all major platforms.
It depends on:

* https://www.python.org/[Python 3.4]
* http://matplotlib.org/[matplotlib]

=== Linux

. Install latest Python 3 using package manager.
. Execute `pip install matplotlib`

=== OS X

. Install http://brew.sh/[Homebrew]
. Install Python 3 `brew install python3`
. Execute `pip3 install matplotlib`

=== Windows

. Install latest Python 3 from https://www.python.org/[www.python.org].
. Open Command Line and go to `C:\Python34\Scripts` (assuming default installation path).
. Execute `pip.exe install matplotlib`.
  This step may fail if Visual $$C++$$ 2010 (part of Visual Studio 2010) is not installed.
  Visual C++ is available http://www.dobreprogramy.pl/Visual-C,Program,Windows,12107.html[here].

== Experiment

Each experiment constists of few steps.
First, a file describing model has to be created.
Based on the model file, a sequence on packet arrival events is generated.
The sequence is used in simulation of both algorithms (algorithm under test and adversary's).

=== Model

A model file contains all model parameters:

. packet lengths; separated with spaces,
. parameter &#955;; has to be &#8805; 0.0,
. length distribution; separated with spaces (i-th element on the list corresponds to i-th packet length),
. speedup; has to be &#8805; 1.0.

Example model file may look like this:

.model.in
----
3 5 7
5.0
0.33 0.17 0.5
1.5
----

In this example new packets appear with rate 5.
The propability of length 5 is 17%, length 3 -- 33% and half of packets have length 7.
Simulation using this model gives an algorithm a 1.5 speedup.

=== Generate

To generate a sequence of inject events use:

 generate.py <generator> <n> <model-file>

`<generator>` is the name of one of available generators,
`<n>` is the number of events to generate
and `<model-file>` points to a file with model description.

==== Available generators

* `sirocco_thm9` -- generates an inject event sequance using the strategy described in Theorem 9 (distribution parameters are ignored).
* `stochastic` -- generates inject events according to Poisson process with parameter &#955;.
   Packet length is randomly chosen with the probability from model file.

=== Simulate

To run a simulation of an algorithm use:

 simulate.py <algorithm> <adversary> <events-file> <model-file>

`<algorithm>` is the name of one of available algorithms,
`<adversary>` is the name of one of available adversaries,
`<events-file>` is the file with packet arrival events generated in the previous step
and `<model-file>` points to a file with model description.

The simulation produces a log that contains records
what the algorithm and the adversary were doing over time.
It includes information about packet arrivals, error injections,
successful and unsuccessful packet transmissions.

==== Algorithm

* `SL` -- Shortest Length
* `LL` -- Longest Length
* `SLPreamble`
* `CSLPreamble`
* `Greedy`
* `Prudent`
* `ESLPreamble`

==== Adversary

* `SiroccoThm9` -- Adversary from Theorem 9
* `SiroccoThm11` -- Adversary from Theorem 11
* `Sirocco` -- Adversary from section 4.1 in paper
* `ESirocco` -- Adversary from part 3.2.1 in thesis

=== plot.py

 plot.py <log>

Draw a simple graph of ratio: (sent by alg up to time t) / (sent by adv up to time t) over time t.

== Algorithm

The main part of an algorithm is the `schedule` method that is called every time algorithm can make a scheduling decision.
Usually in reaction on an event.

[source,python]
----
class Algorithm:
    def schedule(self): # <1>
        pass
----
<1> Schedule packet method -- it returns scheduled packet length or `None` when algorithm is not going to sent anything.

NOTE: Handling packets queue is done internally.

== Adversary

Adversary consists of `schedule` and `scheduleError` methods.
Former one is used in adversary's algorithm (OFF or OPT).
Latter one is used to cause errors on the link.

[source,python]
----
class Adversary(Algorithm):
    def schedule(self): # <1>
        pass

    def algorithmSchedules(self, packet): # <2>
        pass

    def adversarySchedules(self, packet): # <3>
    	pass
----
<1> Schedule packet method -- it returns scheduled packet length or `None` when algorithm is not going to sent anything.
<2> Schedule error method -- return time in which next error occurs (in reaction on packet scheduled by algorithm)
<3> Schedule error method -- return time in which next error occurs (in reaction on packet scheduled by adversary)

NOTE: Handling packets queue is done internally.
