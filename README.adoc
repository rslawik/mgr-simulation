= mgr-simulation
:icons: font
Rafał Sławik <rafal.slawik@gmail.com>

Simulation framework for online packet scheduling algorithms.

== Overview

Framework simulates a scheduling algorithm against some adversary,
who has control over packet arrivals and error injections.
When algorithm under test makes a scheduling decision, adversary is asked to schedule an error.

NOTE: It is required to implement an algorithm and an adversary in a special form.

Work is based on following research papers:
[bibliography]
- [[[sirocco]]] A. F. Anta, C. Georgiou, D. R. Kowalski, J. Widmer, and E. Zavou,
  _Measuring the impact of adversarial errors on packet scheduling strategies_.
  SIROCCO 2013, Springer.

== Installation

The simulation framework works on all major platforms.
It depends on:

* https://www.python.org/[Python 3.4]
* http://matplotlib.org/[matplotlib]

=== Linux

. Install latest Python 3 using package manager.
. Execute `pip install matplotlib`

=== OS X

. Install http://brew.sh/[Homebrew]
. Install Python 3 `brew install python3`
. Execute `pip3 install matplotlib`

=== Windows

. Install latest Python 3 from https://www.python.org/[www.python.org].
. Open Command Line and go to `C:\Python34\Scripts` (assuming default installation path).
. Execute `pip.exe install matplotlib`.
  This step may fail if Visual $$C++$$ 2010 (part of Visual Studio 2010) is not installed.
  Visual C++ is available http://www.dobreprogramy.pl/Visual-C,Program,Windows,12107.html[here].

== Experiment

Each experiment constists of few steps.
First, a file describing model has to be created.
Based on the model file, a sequence on packet arrival events is generated.
The sequence is used in simulation of both algorithms (algorithm under test and adversary's).

=== Model

A model file contains all model parameters:

. packet lengths; separated with spaces,
. parameter &#955;; has to be &#8805; 0.0,
. length distribution; separated with spaces (i-th element on the list corresponds to i-th packet length),
. speedup; has to be &#8805; 1.0.

Example model file may look like this:

.model.in
----
3 5 7
5.0
0.33 0.17 0.5
1.5
----

In this example new packets appear with rate 5.
The propability of length 5 is 17%, length 3 -- 33% and half of packets have length 7.
Simulation using this model gives an algorithm a 1.5 speedup.

=== Generate

To generate a sequence of inject events use:

 generate.py <generator> <n> <model-file>

`<generator>` is the name of one of available generators,
`<n>` is the number of events to generate
and `<model-file>` points to a file with model description.

==== Available generators

* `sirocco_thm9` -- generates an inject event sequance using the strategy described in Theorem 9 (distribution parameters are ignored).
* `stochastic` -- generates inject events according to Poisson process with parameter &#955;.
   Packet length is randomly chosen with the probability from model file.

==== Output format
The result is a sequence of pairs (time and the length of a packet).
Without loss of generality time starts with the arrival of first packet.
An example result looks like this:

.events.in
----
0.0 10.0
2.459899742060707 1.0
5.383135023609432 5.0
6.710508745166248 10.0
9.397366473753106 5.0
11.41576280873459 1.0
12.265779790163247 10.0
12.433092337654008 10.0
17.43791330370601 10.0
19.84048150554071 1.0
...
----

=== Simulate

To run a simulation of an algorithm use:

 simulate.py <algorithm> <adversary> <events-file> <model-file>

`<algorithm>` is the name of one of available algorithms,
`<adversary>` is the name of one of available adversaries,
`<events-file>` is the file with packet arrival events generated in the previous step
and `<model-file>` points to a file with model description.

==== Algorithm

* `SL` -- Shortest Length
* `LL` -- Longest Length
* `SLPreamble`
* `CSLPreamble`
* `Greedy`
* `Prudent`
* `ESLPreamble`

==== Adversary

* `SiroccoThm9` -- the adversary from the proof of Theorem 9 in <<sirocco>>,
 used to show an upper bound for the throughput of algorithm SL under adversarial arrivals,
* `SiroccoThm11` -- the adversary from the proof of Theorem 11 in <<sirocco>>,
 used to show that algorithm LL cannot achieve relative throughput larger than 0,
 even under stochastic arrivals,
* `Sirocco` -- Adversary from section 4.1 in paper
* `ESirocco` -- Adversary from part 3.2.1 in thesis

==== Output format

The simulation produces a log that contains records
what the algorithm and the adversary were doing over time.
It includes information about packet arrivals, error injections,
successful and unsuccessful packet transmissions.
An example log of a simulation looks like this:

.simulation.log
----
...
138.68732775266903 inject 1.0
138.68732775266903 error
138.68732775266903 error
138.68732775266903 schedule ALG 1.0
138.68732775266903 schedule ADV 5.0
139.68732775266903 sent ALG
139.68732775266903 schedule ALG 5.0
143.68732775266903 sent ADV
143.68732775266903 error
...
----

=== plot.py

 plot.py <log>

Draw a simple graph of ratio: (sent by alg up to time t) / (sent by adv up to time t) over time t.

== Algorithm

The main part of an algorithm is the `schedule` method that is called every time algorithm can make a scheduling decision.
Usually in reaction on an event.

[source,python]
----
class Algorithm:
    def schedule(self): # <1>
        pass
----
<1> Schedule packet method -- it returns scheduled packet length or `None` when algorithm is not going to sent anything.

NOTE: Handling packets queue is done internally.

== Adversary

Adversary consists of `schedule` and `scheduleError` methods.
Former one is used in adversary's algorithm (OFF or OPT).
Latter one is used to cause errors on the link.

[source,python]
----
class Adversary(Algorithm):
    def schedule(self): # <1>
        pass

    def algorithmSchedules(self, packet): # <2>
        pass

    def adversarySchedules(self, packet): # <3>
    	pass
----
<1> Schedule packet method -- it returns scheduled packet length or `None` when algorithm is not going to sent anything.
<2> Schedule error method -- return time in which next error occurs (in reaction on packet scheduled by algorithm)
<3> Schedule error method -- return time in which next error occurs (in reaction on packet scheduled by adversary)

NOTE: Handling packets queue is done internally.
